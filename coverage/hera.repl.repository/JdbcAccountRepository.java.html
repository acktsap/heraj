<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ko"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JdbcAccountRepository.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">heraj</a> &gt; <a href="index.source.html" class="el_package">hera.repl.repository</a> &gt; <span class="el_source">JdbcAccountRepository.java</span></div><h1>JdbcAccountRepository.java</h1><pre class="source lang-java linenums">/*
 * @copyright defined in LICENSE.txt
 */

package hera.repl.repository;

import static hera.util.CryptoUtils.decryptFromAes128EcbWithBase64;
import static hera.util.CryptoUtils.encryptToAes128EcbWithBase64;
import static java.util.Optional.empty;
import static java.util.Optional.ofNullable;
import static org.slf4j.LoggerFactory.getLogger;

import hera.api.model.Transaction;
import hera.repl.AccountRepository;
import hera.repl.SecuredAccount;
import hera.util.CryptoUtils;
import hera.util.HexUtils;
import hera.util.pki.ECDSAKey;
import hera.util.pki.ECDSAKeyGenerator;
import java.io.IOException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Optional;
import java.util.function.Supplier;
import javax.crypto.spec.SecretKeySpec;
import lombok.Getter;
import org.slf4j.Logger;

public class JdbcAccountRepository implements AccountRepository {

  protected static final String CREATE_TABLE =
      &quot;CREATE TABLE AERGO_ACCOUNT ( ADDRESS VARCHAR(256) PRIMARY KEY, PRIVATE_KEY VARCHAR(1024) )&quot;;

  protected static final String LIST_QUERY =
      &quot;SELECT * FROM AERGO_ACCOUNT&quot;;

  protected static final String GET_QUERY =
      &quot;SELECT * FROM AERGO_ACCOUNT where ADDRESS = ?&quot;;

  protected static final String DELETE_QUERY =
      &quot;DELETE FROM AERGO_ACCOUNT WHERE ADDRESS = ?&quot;;

  protected static final String SAVE_QUERY =
      &quot;INSERT INTO AERGO_ACCOUNT (ADDRESS, PRIVATE_KEY) VALUES (?, ?)&quot;;

<span class="fc" id="L51">  protected final transient Logger logger = getLogger(getClass());</span>

<span class="nc" id="L53">  @Getter</span>
  protected final Supplier&lt;Connection&gt; connectionSupplier;

<span class="fc" id="L56">  protected final HashMap&lt;String, ECDSAKey&gt; unlockedKeys = new HashMap&lt;&gt;();</span>

<span class="fc" id="L58">  public JdbcAccountRepository(final Supplier&lt;Connection&gt; connectionSupplier) {</span>
<span class="fc" id="L59">    this.connectionSupplier = connectionSupplier;</span>
<span class="fc" id="L60">    createTable();</span>
<span class="fc" id="L61">  }</span>


  /**
   * Create table.
   * &lt;p&gt;
   * Ignore on exception. It will be expected as the table already exists.
   * &lt;/p&gt;
   */
  public void createTable() {
<span class="fc" id="L71">    try (final Connection connection = connectionSupplier.get();</span>
<span class="fc" id="L72">        final PreparedStatement ps = connection.prepareStatement(CREATE_TABLE)</span>
    ) {
<span class="fc" id="L74">      ps.execute();</span>
<span class="nc" id="L75">    } catch (final SQLException e) {</span>
      // Ignore exception
<span class="fc" id="L77">    }</span>
<span class="fc" id="L78">  }</span>

  @Override
  public List&lt;SecuredAccount&gt; list() throws IOException {
<span class="fc" id="L82">    try (final Connection connection = connectionSupplier.get();</span>
<span class="fc" id="L83">        final PreparedStatement ps = connection.prepareStatement(LIST_QUERY);</span>
<span class="fc" id="L84">        final ResultSet rs = ps.executeQuery()</span>
    ) {
<span class="fc" id="L86">      final ArrayList&lt;SecuredAccount&gt; accounts = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">      while (rs.next()) {</span>
<span class="nc" id="L88">        final String encodedAddress = rs.getString(1);</span>
<span class="nc" id="L89">        final String securedPrivateKey = rs.getString(2);</span>
<span class="nc" id="L90">        final SecuredAccount account = new SecuredAccount();</span>
<span class="nc" id="L91">        account.setEncodedAddress(encodedAddress);</span>
<span class="nc" id="L92">        account.setSecuredPrivateKey(securedPrivateKey);</span>
<span class="nc" id="L93">        accounts.add(account);</span>
<span class="nc" id="L94">      }</span>
<span class="fc" id="L95">      return accounts;</span>
<span class="nc" id="L96">    } catch (final SQLException e) {</span>
<span class="nc" id="L97">      throw new IOException(e);</span>
    }
  }

  @Override
  public Optional&lt;SecuredAccount&gt; find(final String address) throws IOException {
<span class="fc" id="L103">    try (final Connection connection = connectionSupplier.get();</span>
<span class="fc" id="L104">        final PreparedStatement ps = connection.prepareStatement(GET_QUERY);</span>
    ) {
<span class="fc" id="L106">      ps.setString(1, address);</span>
<span class="fc" id="L107">      try (final ResultSet rs = ps.executeQuery()) {</span>
<span class="fc" id="L108">        logger.debug(&quot;Next =&gt;&quot;);</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">        while (rs.next()) {</span>
<span class="fc" id="L110">          logger.debug(&quot;Next =&gt;&quot;);</span>
<span class="fc" id="L111">          final String encodedAddress = rs.getString(1);</span>
<span class="fc" id="L112">          final String securedPrivateKey = rs.getString(2);</span>
<span class="fc" id="L113">          final SecuredAccount account = new SecuredAccount();</span>
<span class="fc" id="L114">          account.setEncodedAddress(encodedAddress);</span>
<span class="fc" id="L115">          account.setSecuredPrivateKey(securedPrivateKey);</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">          if (rs.next()) {</span>
<span class="nc" id="L117">            throw new IllegalStateException();</span>
          }
<span class="fc" id="L119">          return ofNullable(account);</span>
        }
<span class="fc" id="L121">        return empty();</span>
      }
<span class="nc" id="L123">    } catch (final SQLException e) {</span>
<span class="nc" id="L124">      throw new IOException(e);</span>
    }
  }

  @Override
  public SecuredAccount create(final String password) throws Exception {
<span class="fc" id="L130">    final SecuredAccount securedAccount = new SecuredAccount();</span>
<span class="fc" id="L131">    final ECDSAKey key = new ECDSAKeyGenerator().create();</span>
<span class="fc" id="L132">    final byte[] privateKeyValue = key.getPrivateKey().getEncoded();</span>
<span class="fc" id="L133">    final byte[] publicKeyValue = key.getPublicKey().getEncoded();</span>
<span class="fc" id="L134">    final String readablePublicKeyValue = HexUtils.encode(publicKeyValue);</span>

<span class="fc" id="L136">    final byte[] passwordBytes = password.getBytes(&quot;UTF-8&quot;);</span>
<span class="fc" id="L137">    final SecretKeySpec secretKeySpec = CryptoUtils.createSecret(passwordBytes, 16);</span>
<span class="fc" id="L138">    final String secured = encryptToAes128EcbWithBase64(privateKeyValue, secretKeySpec);</span>
<span class="fc" id="L139">    securedAccount.setSecuredPrivateKey(secured);</span>
<span class="fc" id="L140">    securedAccount.setEncodedAddress(readablePublicKeyValue);</span>
<span class="fc" id="L141">    save(securedAccount);</span>
<span class="fc" id="L142">    return securedAccount;</span>
  }

  @Override
  public boolean delete(final String encodedAddress) throws IOException {
<span class="fc" id="L147">    try (final Connection connection = connectionSupplier.get();</span>
<span class="fc" id="L148">        final PreparedStatement ps = connection.prepareStatement(DELETE_QUERY)</span>
    ) {
<span class="fc" id="L150">      ps.setString(1, encodedAddress);</span>
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">      return 1 == ps.executeUpdate();</span>
<span class="nc" id="L152">    } catch (final SQLException e) {</span>
<span class="nc" id="L153">      throw new IOException(e);</span>
    }
  }

  @Override
  public void save(SecuredAccount account) throws IOException {
<span class="fc" id="L159">    try (final Connection connection = connectionSupplier.get();</span>
<span class="fc" id="L160">        final PreparedStatement ps = connection.prepareStatement(SAVE_QUERY)</span>
    ) {
<span class="fc" id="L162">      ps.setString(1, account.getEncodedAddress());</span>
<span class="fc" id="L163">      ps.setString(2, account.getSecuredPrivateKey());</span>
<span class="fc" id="L164">      ps.execute();</span>
<span class="nc" id="L165">    } catch (final SQLException e) {</span>
<span class="nc" id="L166">      throw new IOException(e);</span>
<span class="fc" id="L167">    }</span>
<span class="fc" id="L168">  }</span>

  protected ECDSAKey extractPrivateKey(
      final SecuredAccount securedAccount,
      final String password)
      throws Exception {
<span class="fc" id="L174">    final String encodedPrivateKey = securedAccount.getSecuredPrivateKey();</span>
<span class="fc" id="L175">    final byte[] passwordBytes = password.getBytes(&quot;UTF-8&quot;);</span>
<span class="fc" id="L176">    final SecretKeySpec secretKeySpec = CryptoUtils.createSecret(passwordBytes, 16);</span>

<span class="fc" id="L178">    final byte[] privateKey = decryptFromAes128EcbWithBase64(encodedPrivateKey, secretKeySpec);</span>
<span class="fc" id="L179">    return new ECDSAKeyGenerator().create(privateKey);</span>
  }

  @Override
  public void unlock(final String address, final String password) throws IOException {
<span class="fc" id="L184">    final Optional&lt;SecuredAccount&gt; securedAccountOptional = find(address);</span>
    try {
<span class="fc" id="L186">      final SecuredAccount securedAccount = securedAccountOptional.get();</span>
<span class="fc" id="L187">      final ECDSAKey key = extractPrivateKey(securedAccount, password);</span>
<span class="fc" id="L188">      unlockedKeys.put(securedAccount.getEncodedAddress(), key);</span>
<span class="nc" id="L189">    } catch (final Throwable ex) {</span>
<span class="nc" id="L190">      throw new IllegalArgumentException(</span>
          &quot;Fail to unlock &quot; + address + &quot;. Check address and password&quot;, ex);
<span class="fc" id="L192">    }</span>
<span class="fc" id="L193">  }</span>

  @Override
  public void lock(final String address, final String password) throws IOException {
<span class="fc" id="L197">    final Optional&lt;SecuredAccount&gt; securedAccountOptional = find(address);</span>
<span class="fc" id="L198">    securedAccountOptional.ifPresent(securedAccount -&gt; {</span>
      try {
<span class="fc" id="L200">        extractPrivateKey(securedAccount, password);</span>
<span class="fc" id="L201">        unlockedKeys.remove(address);</span>
<span class="nc" id="L202">      } catch (final Throwable ex) {</span>
<span class="nc" id="L203">        throw new IllegalArgumentException(</span>
            &quot;Fail to lock &quot; + address + &quot;. Check address and password&quot;, ex);
<span class="fc" id="L205">      }</span>
<span class="fc" id="L206">    });</span>
<span class="fc" id="L207">  }</span>

  @Override
  public void sendTransaction(final Transaction transaction) throws IOException {
<span class="fc" id="L211">    throw new UnsupportedOperationException();</span>
  }

  @Override
  public void close() throws IOException {
<span class="nc" id="L216">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>