<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KeyStoreBaseTemplate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">heraj</a> &gt; <a href="index.source.html" class="el_package">hera.client.internal</a> &gt; <span class="el_source">KeyStoreBaseTemplate.java</span></div><h1>KeyStoreBaseTemplate.java</h1><pre class="source lang-java linenums">/*
 * @copyright defined in LICENSE.txt
 */

package hera.client.internal;

import static hera.util.TransportUtils.sha256AndEncodeHexa;
import static org.slf4j.LoggerFactory.getLogger;
import static types.AergoRPCServiceGrpc.newFutureStub;

import hera.ContextProvider;
import hera.ContextProviderInjectable;
import hera.annotation.ApiAudience;
import hera.annotation.ApiStability;
import hera.api.function.Function0;
import hera.api.function.Function1;
import hera.api.function.Function3;
import hera.api.model.AccountAddress;
import hera.api.model.Authentication;
import hera.api.model.EncryptedPrivateKey;
import hera.api.model.RawTransaction;
import hera.api.model.Transaction;
import hera.client.ChannelInjectable;
import hera.transport.AccountAddressConverterFactory;
import hera.transport.AuthenticationConverterFactory;
import hera.transport.EncryptedPrivateKeyConverterFactory;
import hera.transport.ModelConverter;
import hera.transport.TransactionConverterFactory;
import io.grpc.ManagedChannel;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Future;
import lombok.Getter;
import org.slf4j.Logger;
import types.AccountOuterClass;
import types.AergoRPCServiceGrpc.AergoRPCServiceFutureStub;
import types.Blockchain;
import types.Rpc;

@ApiAudience.Private
@ApiStability.Unstable
<span class="fc" id="L42">public class KeyStoreBaseTemplate implements ChannelInjectable, ContextProviderInjectable {</span>

<span class="fc" id="L44">  protected final transient Logger logger = getLogger(getClass());</span>

<span class="fc" id="L46">  protected final ModelConverter&lt;EncryptedPrivateKey, Rpc.SingleBytes&gt; encryptedPkConverter =</span>
<span class="fc" id="L47">      new EncryptedPrivateKeyConverterFactory().create();</span>

<span class="fc" id="L49">  protected final ModelConverter&lt;AccountAddress,</span>
      com.google.protobuf.ByteString&gt; accountAddressConverter =
<span class="fc" id="L51">          new AccountAddressConverterFactory().create();</span>

<span class="fc" id="L53">  protected final ModelConverter&lt;Authentication, Rpc.Personal&gt; authenticationConverter =</span>
<span class="fc" id="L54">      new AuthenticationConverterFactory().create();</span>

<span class="fc" id="L56">  protected final ModelConverter&lt;Transaction, Blockchain.Tx&gt; transactionConverter =</span>
<span class="fc" id="L57">      new TransactionConverterFactory().create();</span>

<span class="nc" id="L59">  @Getter</span>
  protected AergoRPCServiceFutureStub aergoService;

  protected ContextProvider contextProvider;

  @Override
  public void setChannel(final ManagedChannel channel) {
<span class="nc" id="L66">    this.aergoService = newFutureStub(channel);</span>
<span class="nc" id="L67">  }</span>

  @Override
  public void setContextProvider(final ContextProvider contextProvider) {
<span class="nc" id="L71">    this.contextProvider = contextProvider;</span>
<span class="nc" id="L72">  }</span>

<span class="fc" id="L74">  @Getter</span>
  private final Function0&lt;
<span class="fc" id="L76">      Future&lt;List&lt;AccountAddress&gt;&gt;&gt; listFunction = new Function0&lt;Future&lt;List&lt;AccountAddress&gt;&gt;&gt;() {</span>

        @Override
        public Future&lt;List&lt;AccountAddress&gt;&gt; apply() {
<span class="fc" id="L80">          logger.debug(&quot;List keystore addresses&quot;);</span>

<span class="fc" id="L82">          final Rpc.Empty empty = Rpc.Empty.newBuilder().build();</span>
<span class="fc" id="L83">          logger.trace(&quot;AergoService getAccounts arg: {}&quot;, empty);</span>

<span class="fc" id="L85">          final Future&lt;AccountOuterClass.AccountList&gt; rawFuture = aergoService.getAccounts(empty);</span>
<span class="fc" id="L86">          final Future&lt;List&lt;AccountAddress&gt;&gt; convertedFuture = HerajFutures.transform(rawFuture,</span>
<span class="fc" id="L87">              new Function1&lt;AccountOuterClass.AccountList, List&lt;AccountAddress&gt;&gt;() {</span>

                @Override
                public List&lt;AccountAddress&gt; apply(
                    final AccountOuterClass.AccountList rpcAccountList) {
<span class="fc" id="L92">                  final List&lt;AccountAddress&gt; domainAccountList = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">                  for (final AccountOuterClass.Account rpcAccount : rpcAccountList</span>
<span class="fc" id="L94">                      .getAccountsList()) {</span>
<span class="nc" id="L95">                    final AccountAddress domainAccount =</span>
<span class="nc" id="L96">                        accountAddressConverter.convertToDomainModel(rpcAccount.getAddress());</span>
<span class="nc" id="L97">                    domainAccountList.add(domainAccount);</span>
<span class="nc" id="L98">                  }</span>
<span class="fc" id="L99">                  return domainAccountList;</span>
                }
              });
<span class="fc" id="L102">          return convertedFuture;</span>
        }
      };

<span class="fc" id="L106">  @Getter</span>
  private final Function1&lt;String,
<span class="fc" id="L108">      Future&lt;AccountAddress&gt;&gt; createFunction = new Function1&lt;String, Future&lt;AccountAddress&gt;&gt;() {</span>

        @Override
        public Future&lt;AccountAddress&gt; apply(final String password) {
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">          if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L113">            logger.debug(&quot;Create an account to server keystore with password: {}&quot;,</span>
<span class="fc" id="L114">                sha256AndEncodeHexa(password));</span>
          }

          final Rpc.Personal rpcPassword =
<span class="fc" id="L118">              Rpc.Personal.newBuilder().setPassphrase(password).build();</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">          if (logger.isTraceEnabled()) {</span>
<span class="nc" id="L120">            logger.trace(&quot;AergoService createAccount arg: {}&quot;,</span>
<span class="nc" id="L121">                sha256AndEncodeHexa(rpcPassword.getPassphrase()));</span>
          }

<span class="fc" id="L124">          final Future&lt;AccountOuterClass.Account&gt; rawFuture =</span>
<span class="fc" id="L125">              aergoService.createAccount(rpcPassword);</span>
<span class="fc" id="L126">          final Future&lt;AccountAddress&gt; convertedFuture = HerajFutures.transform(rawFuture,</span>
<span class="fc" id="L127">              new Function1&lt;AccountOuterClass.Account, AccountAddress&gt;() {</span>

                @Override
                public AccountAddress apply(final AccountOuterClass.Account rpcAccount) {
<span class="fc" id="L131">                  return accountAddressConverter.convertToDomainModel(rpcAccount.getAddress());</span>
                }
              });
<span class="fc" id="L134">          return convertedFuture;</span>
        }
      };

<span class="fc" id="L138">  @Getter</span>
  private final Function1&lt;Authentication,
<span class="fc" id="L140">      Future&lt;Boolean&gt;&gt; unlockFunction = new Function1&lt;Authentication, Future&lt;Boolean&gt;&gt;() {</span>

        @Override
        public Future&lt;Boolean&gt; apply(final Authentication authentication) {
<span class="fc" id="L144">          logger.debug(&quot;Unlock an account in server keystore with authentication: {}&quot;,</span>
              authentication);

<span class="fc" id="L147">          final Rpc.Personal rpcAuthentication =</span>
<span class="fc" id="L148">              authenticationConverter.convertToRpcModel(authentication);</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">          if (logger.isTraceEnabled()) {</span>
<span class="nc" id="L150">            logger.trace(&quot;AergoService unlockAccount arg: {}, {}&quot;,</span>
<span class="nc" id="L151">                rpcAuthentication.getAccount(),</span>
<span class="nc" id="L152">                sha256AndEncodeHexa(rpcAuthentication.getPassphrase()));</span>
          }

<span class="fc" id="L155">          final Future&lt;AccountOuterClass.Account&gt; rawFuture =</span>
<span class="fc" id="L156">              aergoService.unlockAccount(rpcAuthentication);</span>
<span class="fc" id="L157">          final Future&lt;Boolean&gt; convertedFuture = HerajFutures.transform(rawFuture,</span>
<span class="fc" id="L158">              new Function1&lt;AccountOuterClass.Account, Boolean&gt;() {</span>

                @Override
                public Boolean apply(final AccountOuterClass.Account rpcAccount) {
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">                  return null != rpcAccount.getAddress();</span>
                }
              });
<span class="fc" id="L165">          return convertedFuture;</span>
        }
      };

<span class="fc" id="L169">  @Getter</span>
  private final Function1&lt;Authentication, Future&lt;Boolean&gt;&gt; lockFunction =
<span class="fc" id="L171">      new Function1&lt;Authentication, Future&lt;Boolean&gt;&gt;() {</span>

        @Override
        public Future&lt;Boolean&gt; apply(final Authentication authentication) {
<span class="fc" id="L175">          logger.debug(&quot;Lock an account in server keystore with authentication: {}&quot;,</span>
              authentication);

<span class="fc" id="L178">          final Rpc.Personal rpcAuthentication =</span>
<span class="fc" id="L179">              authenticationConverter.convertToRpcModel(authentication);</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">          if (logger.isTraceEnabled()) {</span>
<span class="nc" id="L181">            logger.trace(&quot;AergoService lockAccount arg: {}&quot;,</span>
<span class="nc" id="L182">                sha256AndEncodeHexa(rpcAuthentication.getPassphrase()));</span>
          }

<span class="fc" id="L185">          final Future&lt;AccountOuterClass.Account&gt; rawFuture =</span>
<span class="fc" id="L186">              aergoService.lockAccount(rpcAuthentication);</span>
<span class="fc" id="L187">          final Future&lt;Boolean&gt; convertedFuture = HerajFutures.transform(rawFuture,</span>
<span class="fc" id="L188">              new Function1&lt;AccountOuterClass.Account, Boolean&gt;() {</span>

                @Override
                public Boolean apply(final AccountOuterClass.Account rpcAccount) {
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">                  return null != rpcAccount.getAddress();</span>
                }
              });
<span class="fc" id="L195">          return convertedFuture;</span>
        }
      };

<span class="pc" id="L199">  @Getter</span>
  private final Function1&lt;RawTransaction,
<span class="fc" id="L201">      Future&lt;Transaction&gt;&gt; signFunction = new Function1&lt;RawTransaction, Future&lt;Transaction&gt;&gt;() {</span>

        @Override
        public Future&lt;Transaction&gt; apply(final RawTransaction rawTransaction) {
<span class="nc" id="L205">          logger.debug(&quot;Sign request with rawTx: {}&quot;, rawTransaction);</span>

          final Transaction domainTransaction =
<span class="nc" id="L208">              Transaction.newBuilder().rawTransaction(rawTransaction).build();</span>
<span class="nc" id="L209">          final Blockchain.Tx rpcTx = transactionConverter.convertToRpcModel(domainTransaction);</span>
<span class="nc" id="L210">          logger.trace(&quot;AergoService signTX arg: {}&quot;, rpcTx);</span>

<span class="nc" id="L212">          final Future&lt;Blockchain.Tx&gt; rawFuture = aergoService.signTX(rpcTx);</span>
<span class="nc" id="L213">          final Future&lt;Transaction&gt; convertedFuture =</span>
<span class="nc" id="L214">              HerajFutures.transform(rawFuture, new Function1&lt;Blockchain.Tx, Transaction&gt;() {</span>
                @Override
                public Transaction apply(final Blockchain.Tx tx) {
<span class="nc" id="L217">                  return transactionConverter.convertToDomainModel(tx);</span>
                }
              });
<span class="nc" id="L220">          return convertedFuture;</span>
        }
      };

<span class="fc" id="L224">  @Getter</span>
  private final Function3&lt;EncryptedPrivateKey, String, String,
      Future&lt;AccountAddress&gt;&gt; importKeyFunction = new Function3&lt;EncryptedPrivateKey, String, String,
<span class="fc" id="L227">          Future&lt;AccountAddress&gt;&gt;() {</span>

        @Override
        public Future&lt;AccountAddress&gt; apply(final EncryptedPrivateKey encryptedKey,
            final String oldPassword, final String newPassword) {
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">          if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L233">            logger.debug(</span>
                &quot;Import an account to server keystore with &quot;
                    + &quot;encryptedKey: {}, oldPassword: {}, newPassword: {}&quot;,
<span class="fc" id="L236">                encryptedKey, sha256AndEncodeHexa(oldPassword),</span>
<span class="fc" id="L237">                sha256AndEncodeHexa(newPassword));</span>
          }

<span class="fc" id="L240">          final Rpc.ImportFormat rpcImport = Rpc.ImportFormat.newBuilder()</span>
<span class="fc" id="L241">              .setWif(encryptedPkConverter.convertToRpcModel(encryptedKey))</span>
<span class="fc" id="L242">              .setOldpass(oldPassword).setNewpass(newPassword).build();</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">          if (logger.isTraceEnabled()) {</span>
<span class="nc" id="L244">            logger.trace(</span>
                &quot;AergoService importAccount arg: ImportFormat(wif={}, oldPass={}, newPass={})&quot;,
<span class="nc" id="L246">                rpcImport.getWif(), sha256AndEncodeHexa(rpcImport.getOldpass()),</span>
<span class="nc" id="L247">                sha256AndEncodeHexa(rpcImport.getNewpass()));</span>
          }

<span class="fc" id="L250">          final Future&lt;AccountOuterClass.Account&gt; rawFuture =</span>
<span class="fc" id="L251">              aergoService.importAccount(rpcImport);</span>
<span class="fc" id="L252">          final Future&lt;AccountAddress&gt; convertedFuture = HerajFutures.transform(rawFuture,</span>
<span class="fc" id="L253">              new Function1&lt;AccountOuterClass.Account, AccountAddress&gt;() {</span>

                @Override
                public AccountAddress apply(final AccountOuterClass.Account rpcAccount) {
<span class="fc" id="L257">                  return accountAddressConverter</span>
<span class="fc" id="L258">                      .convertToDomainModel(rpcAccount.getAddress());</span>
                }
              });
<span class="fc" id="L261">          return convertedFuture;</span>
        }
      };

<span class="fc" id="L265">  @Getter</span>
  private final Function1&lt;Authentication, Future&lt;EncryptedPrivateKey&gt;&gt; exportKeyFunction =
<span class="fc" id="L267">      new Function1&lt;Authentication, Future&lt;EncryptedPrivateKey&gt;&gt;() {</span>

        @Override
        public Future&lt;EncryptedPrivateKey&gt; apply(final Authentication authentication) {
<span class="fc" id="L271">          logger.debug(&quot;Export an account from server keystore with authentication: {}&quot;,</span>
              authentication);

<span class="fc" id="L274">          final Rpc.Personal rpcAuthentication =</span>
<span class="fc" id="L275">              authenticationConverter.convertToRpcModel(authentication);</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">          if (logger.isTraceEnabled()) {</span>
<span class="nc" id="L277">            logger.trace(&quot;AergoService exportAccount  arg: Personal(account={}, password={})&quot;,</span>
<span class="nc" id="L278">                rpcAuthentication.getAccount().getAddress(),</span>
<span class="nc" id="L279">                sha256AndEncodeHexa(rpcAuthentication.getPassphrase()));</span>
          }

<span class="fc" id="L282">          final Future&lt;Rpc.SingleBytes&gt; rawFuture =</span>
<span class="fc" id="L283">              aergoService.exportAccount(rpcAuthentication);</span>
<span class="fc" id="L284">          final Future&lt;EncryptedPrivateKey&gt; convertedFuture = HerajFutures.transform(rawFuture,</span>
<span class="fc" id="L285">              new Function1&lt;Rpc.SingleBytes, EncryptedPrivateKey&gt;() {</span>

                @Override
                public EncryptedPrivateKey apply(final Rpc.SingleBytes rawPk) {
<span class="fc" id="L289">                  return encryptedPkConverter.convertToDomainModel(rawPk);</span>
                }
              });
<span class="fc" id="L292">          return convertedFuture;</span>
        }
      };

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>